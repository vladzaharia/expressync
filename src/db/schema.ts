import {
  boolean,
  integer,
  pgTable,
  real,
  serial,
  text,
  timestamp,
} from "drizzle-orm/pg-core";

// ============================================================================
// BETTERAUTH TABLES
// These tables are required by BetterAuth for authentication
// ============================================================================

/**
 * Users table - stores user accounts
 * BetterAuth manages this table for authentication
 */
export const users = pgTable("users", {
  id: text("id").primaryKey(), // UUID generated by BetterAuth
  name: text("name"),
  email: text("email").notNull().unique(),
  emailVerified: boolean("email_verified").default(false),
  image: text("image"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

/**
 * Sessions table - stores active user sessions
 */
export const sessions = pgTable("sessions", {
  id: text("id").primaryKey(),
  userId: text("user_id")
    .notNull()
    .references(() => users.id, { onDelete: "cascade" }),
  token: text("token").notNull().unique(),
  expiresAt: timestamp("expires_at").notNull(),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

/**
 * Accounts table - stores OAuth provider accounts
 * Also used for email/password credentials
 */
export const accounts = pgTable("accounts", {
  id: text("id").primaryKey(),
  userId: text("user_id")
    .notNull()
    .references(() => users.id, { onDelete: "cascade" }),
  accountId: text("account_id").notNull(),
  providerId: text("provider_id").notNull(), // "credential" for email/password
  accessToken: text("access_token"),
  refreshToken: text("refresh_token"),
  accessTokenExpiresAt: timestamp("access_token_expires_at"),
  refreshTokenExpiresAt: timestamp("refresh_token_expires_at"),
  scope: text("scope"),
  password: text("password"), // Hashed password for credential provider
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

/**
 * Verifications table - stores email verification tokens
 */
export const verifications = pgTable("verifications", {
  id: text("id").primaryKey(),
  identifier: text("identifier").notNull(), // Email address
  value: text("value").notNull(), // Verification token
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// ============================================================================
// APPLICATION TABLES
// Custom tables for ExpresSync
// ============================================================================

/**
 * User Mappings - Links StEvE OCPP tags to Lago customers/subscriptions
 *
 * This is the core mapping table that enables billing.
 * Each row links one OCPP ID tag to one Lago subscription.
 */
export const userMappings = pgTable("user_mappings", {
  id: serial("id").primaryKey(),

  // StEvE identifiers
  steveOcppTagPk: integer("steve_ocpp_tag_pk").notNull().unique(),
  steveOcppIdTag: text("steve_ocpp_id_tag").notNull(),

  // Lago identifiers (nullable until mapping is complete)
  lagoCustomerExternalId: text("lago_customer_external_id"),
  lagoSubscriptionExternalId: text("lago_subscription_external_id"),

  // Display information
  displayName: text("display_name"),
  notes: text("notes"),

  // Status
  isActive: boolean("is_active").default(true),

  // Timestamps
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

/**
 * Sync Runs - Tracks each sync execution
 *
 * Stores metadata about each sync run for debugging and monitoring.
 */
export const syncRuns = pgTable("sync_runs", {
  id: serial("id").primaryKey(),

  // Timing
  startedAt: timestamp("started_at").notNull().defaultNow(),
  completedAt: timestamp("completed_at"),

  // Status: "running" | "completed" | "failed"
  status: text("status").notNull().default("running"),

  // Segment statuses: "success" | "warning" | "error" | "skipped" | null (not run yet)
  tagLinkingStatus: text("tag_linking_status"),
  transactionSyncStatus: text("transaction_sync_status"),

  // Statistics
  transactionsProcessed: integer("transactions_processed").default(0),
  eventsCreated: integer("events_created").default(0),

  // Tag linking statistics
  tagsActivated: integer("tags_activated").default(0),
  tagsDeactivated: integer("tags_deactivated").default(0),
  tagsUnchanged: integer("tags_unchanged").default(0),

  // Error tracking (JSON array of error messages)
  errors: text("errors"),
});

/**
 * Sync Run Logs - Detailed logs for each sync run segment
 *
 * Tracks individual operations within each sync segment for debugging.
 * Logs are timestamped and colored by status level.
 */
export const syncRunLogs = pgTable("sync_run_logs", {
  id: serial("id").primaryKey(),

  // Reference to parent sync run
  syncRunId: integer("sync_run_id")
    .notNull()
    .references(() => syncRuns.id, { onDelete: "cascade" }),

  // Segment: "tag_linking" | "transaction_sync"
  segment: text("segment").notNull(),

  // Log level: "info" | "warn" | "error" | "debug"
  level: text("level").notNull().default("info"),

  // Log message
  message: text("message").notNull(),

  // Additional context (JSON)
  context: text("context"),

  // Timestamp
  createdAt: timestamp("created_at").notNull().defaultNow(),
});

/**
 * Transaction Sync State - Tracks incremental meter readings per transaction
 *
 * This table enables incremental billing by storing the last synced
 * meter value for each StEvE transaction. This allows us to:
 * - Bill for in-progress charging sessions
 * - Calculate deltas (only bill for new usage since last sync)
 * - Mark transactions as finalized when completed
 */
export const transactionSyncState = pgTable("transaction_sync_state", {
  id: serial("id").primaryKey(),

  // StEvE transaction reference
  steveTransactionId: integer("steve_transaction_id").notNull().unique(),

  // Last synced meter value (in Wh)
  // Used as the base for calculating the next delta
  lastSyncedMeterValue: integer("last_synced_meter_value").notNull(),

  // Total kWh billed so far for this transaction
  totalKwhBilled: real("total_kwh_billed").default(0),

  // Reference to the last sync run that updated this
  lastSyncRunId: integer("last_sync_run_id").references(() => syncRuns.id),

  // True when the transaction is complete and no more billing will occur
  isFinalized: boolean("is_finalized").default(false),

  // Timestamps
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

/**
 * Synced Transaction Events - Audit log of all Lago events sent
 *
 * Each row represents one usage event sent to Lago.
 * For incremental billing, multiple events may be sent per StEvE transaction.
 */
export const syncedTransactionEvents = pgTable("synced_transaction_events", {
  id: serial("id").primaryKey(),

  // StEvE reference
  steveTransactionId: integer("steve_transaction_id").notNull(),

  // Link to sync state
  transactionSyncStateId: integer("transaction_sync_state_id")
    .references(() => transactionSyncState.id),

  // Lago event details
  lagoEventTransactionId: text("lago_event_transaction_id").notNull().unique(),

  // User mapping reference
  userMappingId: integer("user_mapping_id")
    .references(() => userMappings.id),

  // Usage details for this event (delta, not total)
  kwhDelta: real("kwh_delta").notNull(),

  // Meter values at time of this event
  meterValueFrom: integer("meter_value_from").notNull(), // Base (Wh)
  meterValueTo: integer("meter_value_to").notNull(), // Current (Wh)

  // Whether this was the final event for the transaction
  isFinal: boolean("is_final").default(false),

  // Reference to sync run
  syncRunId: integer("sync_run_id")
    .references(() => syncRuns.id),

  // When this event was created/sent
  syncedAt: timestamp("synced_at").defaultNow(),
});

// ============================================================================
// TYPE EXPORTS
// ============================================================================

export type User = typeof users.$inferSelect;
export type NewUser = typeof users.$inferInsert;

export type Session = typeof sessions.$inferSelect;
export type NewSession = typeof sessions.$inferInsert;

export type Account = typeof accounts.$inferSelect;
export type NewAccount = typeof accounts.$inferInsert;

export type Verification = typeof verifications.$inferSelect;
export type NewVerification = typeof verifications.$inferInsert;

export type UserMapping = typeof userMappings.$inferSelect;
export type NewUserMapping = typeof userMappings.$inferInsert;

export type SyncRun = typeof syncRuns.$inferSelect;
export type NewSyncRun = typeof syncRuns.$inferInsert;

export type TransactionSyncState = typeof transactionSyncState.$inferSelect;
export type NewTransactionSyncState = typeof transactionSyncState.$inferInsert;

export type SyncedTransactionEvent =
  typeof syncedTransactionEvents.$inferSelect;
export type NewSyncedTransactionEvent =
  typeof syncedTransactionEvents.$inferInsert;

export type SyncRunLog = typeof syncRunLogs.$inferSelect;
export type NewSyncRunLog = typeof syncRunLogs.$inferInsert;

// Sync segment types
export type SyncSegment = "tag_linking" | "transaction_sync";
export type SyncSegmentStatus = "success" | "warning" | "error" | "skipped";
export type SyncLogLevel = "info" | "warn" | "error" | "debug";
